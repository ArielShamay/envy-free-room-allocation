"""\nEnvy-Free Room Allocation using Maximum Weight Matching and Longest Path in Envy Graph.\n\nThis module implements a fair division algorithm for the rent division problem,\nensuring that the final allocation is envy-free.\n"""\n\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nimport unittest\n\n\ndef envy_free_room_allocation(valuations: list[list[float]], rent: float) -> tuple[dict, dict]:\n    """\n    Calculates an envy-free allocation of rooms and prices.\n    \n    Args:\n        valuations: A list of lists where valuations[i][j] is the value player i assigns to room j.\n        rent: The total rent sum to be divided among players.\n        \n    Returns:\n        A tuple containing:\n        1. Assignment dictionary: {player_index: room_index}\n        2. Pricing dictionary: {room_index: price}\n    """\n    n = len(valuations)\n    valuations_array = np.array(valuations)\n    \n    # ===================================================================\n    # Phase A: Assignment (Maximizing Social Welfare)\n    # ===================================================================\n    # Use linear_sum_assignment to find maximum weight matching.\n    # Since it minimizes cost, we negate the valuations to maximize.\n    cost_matrix = -valuations_array\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n    \n    # Create assignment dictionary: player -> room\n    assignment = {player: room for player, room in zip(row_ind, col_ind)}\n    \n    # ===================================================================\n    # Phase B: Pricing (Eliminating Envy)\n    # ===================================================================\n    \n    # Build the Envy Graph\n    # Edge weight from player i to player j is:\n    # envy(i,j) = value_i(room_j) - value_i(room_i)\n    envy_graph = np.zeros((n, n))\n    for i in range(n):\n        room_i = assignment[i]\n        for j in range(n):\n            room_j = assignment[j]\n            # Envy of player i towards player j\n            envy_graph[i][j] = valuations_array[i][room_j] - valuations_array[i][room_i]\n    \n    # Calculate subsidies (q_i) using Bellman-Ford algorithm\n    # q_i is the weight of the longest path starting from node i\n    # \n    # WHY Bellman-Ford?\n    # - The envy graph may have negative edges (when player i prefers their own room)\n    # - We need to find LONGEST paths, which we do by finding SHORTEST paths \n    #   in the negated graph (multiply weights by -1)\n    # - Bellman-Ford handles negative edges and detects negative cycles\n    # - Since our assignment maximizes social welfare, there are no positive cycles\n    #   in the envy graph (equivalently, no negative cycles in the negated graph)\n    \n    q = np.zeros(n)\n    for start_node in range(n):\n        # Find longest paths from start_node to all other nodes\n        # by finding shortest paths in the negated graph\n        distances = bellman_ford_longest_path(envy_graph, start_node, n)\n        # q_i is the maximum (longest) path weight from node i\n        q[start_node] = np.max(distances)\n    \n    # Calculate final prices\n    # WHY this formula?\n    # - S = sum of subsidies represents the total \"envy reduction\" needed\n    # - R = total rent to be collected\n    # - We distribute (R + S) equally among players as a base amount: (R+S)/n\n    # - Then subtract each player's subsidy q_i to get their room price\n    # - This ensures: \n    #   1. Sum of prices = R (total rent collected)\n    #   2. Each player's utility (value - price) is envy-free\n    S = np.sum(q)\n    base_amount = (rent + S) / n\n    \n    pricing = {}\n    for player in range(n):\n        room = assignment[player]\n        price = base_amount - q[player]\n        pricing[room] = price\n    \n    return assignment, pricing\n\n\ndef bellman_ford_longest_path(graph: np.ndarray, start: int, n: int) -> np.ndarray:\n    """\n    Find longest paths from start node to all other nodes using Bellman-Ford.\n    \n    We negate the edge weights and find shortest paths, which gives us longest paths\n    in the original graph.\n    \n    Args:\n        graph: Adjacency matrix with edge weights\n        start: Starting node\n        n: Number of nodes\n        \n    Returns:\n        Array of longest path distances from start to each node\n    """\n    # Initialize distances (use negative infinity for longest path)\n    distances = np.full(n, -np.inf)\n    distances[start] = 0\n    \n    # Relax edges n-1 times\n    for _ in range(n - 1):\n        updated = False\n        for i in range(n):\n            if distances[i] == -np.inf:\n                continue\n            for j in range(n):\n                if i != j:  # No self-loops\n                    new_dist = distances[i] + graph[i][j]\n                    if new_dist > distances[j]:\n                        distances[j] = new_dist\n                        updated = True\n        if not updated:\n            break\n    \n    # Set unreachable nodes to 0 (no path means no subsidy)\n    distances[distances == -np.inf] = 0\n    \n    return distances\n\n\ndef print_allocation(valuations: list[list[float]], assignment: dict, pricing: dict):\n    """\n    Print the allocation in a human-readable format.\n    \n    Args:\n        valuations: The original valuations matrix\n        assignment: Player to room assignment\n        pricing: Room to price mapping\n    """\n    for player in sorted(assignment.keys()):\n        room = assignment[player]\n        value = valuations[player][room]\n        price = pricing[room]\n        print(f\"Player {player} gets room {room} with value {value}, and pays {price}\")\n\n\nclass TestEnvyFreeAllocation(unittest.TestCase):\n    \"\"\"Unit tests for the envy-free room allocation algorithm.\"\"\"\n    \n    def test_case1_free_rider(self):\n        \"\"\"Test Case 1: The Free-Rider Problem\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"Test Case 1: Free-Rider Problem\")\n        print(\"=\"*60)\n        \n        valuations = [[150, 0], [140, 10]]\n        rent = 100\n        \n        assignment, pricing = envy_free_room_allocation(valuations, rent)\n        \n        print_allocation(valuations, assignment, pricing)\n        \n        # Verify sum of prices equals total rent\n        total_price = sum(pricing.values())\n        print(f\"\\nTotal rent: {rent}, Sum of prices: {total_price:.2f}\")\n        self.assertAlmostEqual(total_price, rent, places=6, \n                              msg=\"Sum of prices should equal total rent\")\n        \n        # Verify envy-freeness\n        self.assertTrue(self._is_envy_free(valuations, assignment, pricing),\n                       \"Allocation should be envy-free\")\n        \n        # Verify Player 1 pays negative (gets subsidy)\n        player1_room = assignment[1]\n        player1_price = pricing[player1_room]\n        print(f\"Player 1 price: {player1_price:.2f} (should be negative)\")\n        self.assertLess(player1_price, 0, \n                       \"Player 1 should pay a negative price in free-rider problem\")\n        \n        print(\"✓ Test Case 1 PASSED\")\n    \n    def test_case2_standard(self):\n        \"\"\"Test Case 2: Standard example from class\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"Test Case 2: Standard Example\")\n        print(\"=\"*60)\n        \n        valuations = [\n            [35, 40, 25],\n            [35, 60, 40],\n            [25, 40, 20]\n        ]\n        rent = 100\n        \n        assignment, pricing = envy_free_room_allocation(valuations, rent)\n        \n        print_allocation(valuations, assignment, pricing)\n        \n        # Verify sum of prices equals total rent\n        total_price = sum(pricing.values())\n        print(f\"\\nTotal rent: {rent}, Sum of prices: {total_price:.2f}\")\n        self.assertAlmostEqual(total_price, rent, places=6,\n                              msg=\"Sum of prices should equal total rent\")\n        \n        # Verify envy-freeness\n        self.assertTrue(self._is_envy_free(valuations, assignment, pricing),\n                       \"Allocation should be envy-free\")\n        \n        print(\"✓ Test Case 2 PASSED\")\n    \n    def _is_envy_free(self, valuations, assignment, pricing):\n        \"\"\"\n        Check if the allocation is envy-free.\n        \n        For every player i and every other player j:\n        utility_i(own_room) >= utility_i(other_room)\n        where utility = value - price\n        \"\"\"\n        n = len(valuations)\n        for i in range(n):\n            room_i = assignment[i]\n            price_i = pricing[room_i]\n            utility_i = valuations[i][room_i] - price_i\n            \n            for j in range(n):\n                if i != j:\n                    room_j = assignment[j]\n                    price_j = pricing[room_j]\n                    utility_i_if_took_j = valuations[i][room_j] - price_j\n                    \n                    if utility_i < utility_i_if_took_j - 1e-6:  # Allow small numerical error\n                        print(f\"\\nEnvy detected!\")\n                        print(f\"Player {i} envies player {j}\")\n                        print(f\"  Current utility: {utility_i:.4f} (room {room_i}, value {valuations[i][room_i]}, price {price_i:.4f})\")\n                        print(f\"  If took room {room_j}: {utility_i_if_took_j:.4f} (value {valuations[i][room_j]}, price {price_j:.4f})\")\n                        return False\n        \n        print(\"\\n✓ Allocation is envy-free for all players\")\n        return True\n\n\nif __name__ == '__main__':\n    print(\"=\"*60)\n    print(\"ENVY-FREE ROOM ALLOCATION\")\n    print(\"Algorithm: Maximum Weight Matching + Longest Path in Envy Graph\")\n    print(\"=\"*60)\n    \n    # Run the unit tests\n    unittest.main(verbosity=2)\n